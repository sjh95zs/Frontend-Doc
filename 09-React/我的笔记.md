# 我的笔记

## React 基础

- 理解 react 中的组件

- JSX 语法：js 与 html 的结合，遇到 `<` 就当作 html 来解析，遇到 `{` 就当作 js 来解析

- 组件的**首字母必须大写**

- React 要求必须在一个组件的**最外层**进行包裹，比如包裹一层`<div></div>`。如果不加 div，则可以引入 Fragment，它不会渲染到 dom 中

  ```js
  import React, { Component, Fragment } from 'react'

  class Xiaojiejie extends Component {
    render() {
      return (
        <Fragment>
          <div>
            <input type='text' />
            <button>增加服务</button>
          </div>
          <ul>
            <li>头部按摩</li>
            <li>脚底按摩</li>
            <li>肩部按摩</li>
          </ul>
        </Fragment>
      )
    }
  }
  ```

- 数据驱动：与小程序很像

  ```js
  this.setState({
    // ...
  })
  ```

  - 一些坑

    ```js
    // 极力推荐这种更新方式。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数
    this.setState((prevState, prevProps) => ({
      counter: state.counter + props.increment
    }))
    ```

- 事件绑定：注意事件名大写；**需要重新设置 this 的指向**；可以传递参数 data

  ```html
  <button onClick="{this.addList.bind(this, data)}">按钮</button>
  ```

  ```js
  addList(data){
    console.log(data)
  }
  ```

- 列表循环：key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识；如果你提取 出一个 ListItem 组件，你应该把 key 保留在数组中的这个 `<ListItem />` 元素上，而不是放在 ListItem 组件中的 `<li>` 元素上；最好写成一个函数，然后 return 它

  ```js
  <ul>
    {this.state.list.map((item, index) => {
      return <li key={index + item}>{item}</li>
    })}
  </ul>
  ```

- css 类用的是 className="..."，而不是 class="..."

- `dangerouslySetInnerHTML={{ __html: item }}` 设置可以解析 HTML 标签

- label 标签：注意绑定目标用的是 htmlFor，而不是 for

  ```html
  <label htmlFor="jspang">请填写：</label> <input id="jspang" />
  ```

- 代码自动补全插件：Simple React Snippets

- 组件间传值

  - 父传子：属性 props

    ```html
    <!-- 父 -->
    <div>
      <XiaojiejieItem content="{item}" />
    </div>

    <!-- 子 -->
    <li>{this.props.content}</li>
    ```

  - 子传父：子调用父传过来的的方法

- 单向数据流
  父可以改变子的数据，但子不能直接修改父的数据，需要通过调用父的方法

- 可与其他框架并存：比如 jQuery 可以与 react 一起使用，因为 react 只渲染你挂载的元素（本课程是 root 那个元素），其他的元素你可以用 jQ 操作【但并不建议混用，因为很乱的】

- 函数式编程

  - 函数式编程让我们的代码更清晰，每个功能都是一个函数
  - 更容易实现前端自动化测试

- 调试 `React developer tools`，一个 chrome 插件

  1. 灰色：页面不是 React 编写的
  2. 蓝色: 页面是用 React 编写的，并且处于生成环境当中
  3. 红色：页面是用 React 编写的，并且处于调试环境当中

- PropTypes 校验传递值

  ```js
  import PropTypes from 'prop-types' // 引入校验模块

  // 父传子的数据检验
  XiaojiejieItem.propTypes = {
    content: PropTypes.string.isRequired, // isRequired表示必须要传值
    index: PropTypes.number,
    deleteItem: PropTypes.func
  }

  // 设置默认值
  XiaojiejieItem.defaultProps = {
    name: '默认值'
  }
  ```

- ref 的使用方法：给你操作 DOM 的机会

  ```html
  <!-- this.buttonElm 就是指这个button元素 -->
  <button ref={(button) => {this.buttonElm = button}}></button>
  ```

  - 小结

    - ref 写在 html 标签上，获取的是 dom 节点
    - ref 写在组件标签上，获取的是这个组件的 js 实例

- 生命周期

  ![react生命周期](images/react生命周期.png)

  > 每个组件都有一个生命周期
  > 如果有父子关系，执行顺序的进出口都是 render【即父的生命周期执行到 render，就会进入到子的生命周期，子执行完后就会出来，然后父从 render 继续往下执行】

  1. 初始化阶段

     1. constructor(){}：只做 props 和 state 的初始化

  2. 挂载阶段

     > 注意：componentWillMount 和 componentDidMount 这两个生命周期函数，**只在页面刷新时执行一次**，而 render 函数是只要有 state 或 props 变化就会执行

     1. componentWillMount：组件即将被挂载到页面的时刻执行
     2. render：组件初次挂载时会执行一次
     3. componentDidMount：组件挂载完成时被执行


    3. 更新阶段

        - props

          1. componentWillReceiveProps：子组件接收到父组件传递过来的props，父组件render函数重新被执行，这个生命周期就会被执行【它只可能在子组件中执行】
          2. shouldComponentUpdate：在组件更新之前，自动被执行。它要求返回一个布尔值，true就往下走，**false就不执行后面的生命周期函数**
          3. componentWillUpdate：在shouldComponenUpdate之后被执行
          4. render：重新渲染
          5. componentDidUpdate：在组件更新之后执行

        - states

          1. shouldComponentUpdate：在组件更新之前，自动被执行。它要求返回一个布尔值，true就往下走，**false就不执行后面的生命周期函数**
          2. componentWillUpdate：在shouldComponenUpdate之后被执行
          3. render：重新渲染
          4. componentDidUpdate：在组件更新完之后执行

    4. 销毁阶段
        1. componentWillUnmount：组件从页面中删除的时候执行【一般跟路由有关】

- 性能优化：shouldComponentUpdate 这个钩子存在返回值，是有意义的

  ```js
  // nextProps：变化后的属性；nextState：变化后的状态；
  // 此处是只有当Props改变了，才会进行render重新渲染，减少渲染次数
  shouldComponentUpdate(nextProps, nextState) {
    if(nextProps.content !== this.props.content) {
        return true
    } else {
        return false
    }
  }
  ```

- axios 数据请求

  强烈建议：在`componentDidMount（在组件更新之后执行）`这个生命周期函数中写请求

  ```js
  componentDidMount(){
    axios.post('https://web-api.juejin.im/v3/web/wbbr/bgeda')
      .then(res=>{
        console.log('axios 获取数据成功:'+JSON.stringify(res.data))
        })
      .catch(error=>{
        console.log('axios 获取数据失败'+error)
        })
  }
  ```

- 模拟数据请求 EasyMock
  EasyMock 网站:https://www.easy-mock.com/

- CSS3 实现动画

  - 过渡：transition
  - 动画：animation、@keyframes

- 高级动画库 react-transition-group
  三大部分：
  1. Transition
  2. CSSTransition
  3. TransitionGroup：多 DOM 动画制作和编写

## 路由：react-router-dom

> 根据路径的不同，显示不同的组件/页面

- BrowserRouter：创建一个路由，只能有一个根节点
- Route：每一个路由项，每个路由项都和对应的组件创建链接

  ```html
  <BrowserRouter>
    <div>
      <Route path="/list/:id" component="{NewList}" />
      <Route path="/button" component="{NewButton}" />
    </div>
  </BrowserRouter>
  ```

- Link：组件/页面之间的跳转。可以携带参数，参数可通过`this.props.match.params.id`获取

  ```html
  <Link to="/list/123">
    <Button type="primary">按钮</Button>
  </Link>
  ```

- Redirect：重定向，跟下面的 withRouter 类似
- withRouter：可以包装任何自定义组件，将 react-router 的 history,location,match 三个对象传入，实现任意跳转
