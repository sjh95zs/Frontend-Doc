# 原型与原型链

- 原型：利用 prototype 添加**共享的属性和方法**
- 原型链：`__proto__`与`prorotype`的关系链

  ![原型链](img/原型链.png)

- constructor：每个原型对象都有一个 constructor 属性，指向相关联的构造函数

  ```js
  function Cat() {
    this.color = 'orange';
  }

  console.log(Cat.prototype.constructor === Cat); // true
  ```

## 1、五大要点

1. **所有的引用类型都具有对象特性，即可自由扩展属性（除了`null`以外）**
2. **所有的引用类型都有一个(私有属性)`__proto__`，属性值是一个对象**
3. **所有的函数都有一个(原型对象)`prototype`**
4. **所有的引用类型，`__proto__`指向`prototype`**

   ```js
   function Cat(color) {
     this.color = 'orange';
   }

   var cat = new Cat();

   console.log(cat.__proto__ === Cat.prototype); // true
   ```

5. **当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`cat.__proto__`(即 `Cat.prorotype`)中寻找，没找到则去`Cat.prototype.__proto__`中寻找，一直找下去......**

   ```js
   function Cat() {
     this.color = 'orange';
   }
   Cat.prototype.age = 4;

   var cat = new Cat();

   console.log(cat.color); // orange
   console.log(cat.age); // 4
   ```

## 2、继承

### 2.1 构造函数-继承

> 缺点：不能继承原型链上的东西

```js
function Parent() {
  this.name = 'parent';
}

function Child() {
  Parent.call(this); // 构造函数继承
  this.age = 20;
}

console.log(new Child());
```

### 2.2 原型链-继承

> 缺点：来自原型对象的所有属性和方法都是共享的，导致对一个实例的修改会影响另一个实例

```js
function Parent(color, arr) {
  this.color = 'red';
  this.arr = [1, 2, 3];
}
Parent.prototype.walk = 'I can walk';

function Child(age) {
  this.age = 20;
}

Child.prototype = new Parent(); // 原型链继承

const child1 = new Child();
const child2 = new Child();
child1.color = 'blue';

console.log(child1.color); // red
console.log(child2.color); // red
console.log(child1.walk); // I can walk
console.log(child2.walk); // I can walk
```

### 2.3 组合-继承（最常用）

> 弥补了上面 2 种的缺点

例子：动物 》哺乳动物 》人类 》某个人

```js
function Animal(color, weight) {
  this.color = color;
  this.weight = weight;
}
Animal.prototype.eat = function() {
  console.log('chi chi chi');
};

function Mammal(color, weight) {
  Animal.call(this, color, weight); // 继承个性。以构造函数方式调用，this指向创建的那个对象
}
Mammal.prototype = Object.create(Animal.prototype); // 继承共性
Mammal.prototype.constructor = Mammal; // 重设一下构造器
Mammal.prototype.suckle = function() {
  console.log('挤奶');
};

function Person(color, weight) {
  Mammal.call(this, color, weight); // 继承个性。以构造函数方式调用，this指向创建的那个对象
}
Person.prototype = Object.create(Mammal.prototype); // 继承共性
Person.prototype.constructor = Person; // 重设一下构造器
Person.prototype.lie = function() {
  console.log('我很帅');
};

var lsd = new Person('黑色', 65); // 李栓蛋
console.log(lsd);
lsd.eat(); // Animal的能力
lsd.suckle(); // Mammal的能力
lsd.lie(); // Person的能力
var whh = new Person('金色', 100); // 王花花
console.log(whh);
whh.eat();
whh.suckle();
whh.lie();
```

### 要判断一个属性是 xiaoming 自身拥有的，还是继承得到的，可以用 hasOwnProperty()方法

```js
var xiaoming = {
  name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

### 补充

```js
// 构建一个没有任何继承关系的对象，方法如下：
var a = Object.create(null);
console.log(a);
// 还可以自己构建它的原型，方法如下：
var b = Object.create({
  haha: 1,
  hehe: 2
});
console.log(b);
```
